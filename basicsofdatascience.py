# -*- coding: utf-8 -*-
"""BasicsOfDataScience.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ci_EChek-bPxqW5utPj2GqmVX2iWBJYH

# Python Data Science Workshop by GreatLearning
Basics of Data science in Python using NumPy and Pandas

"""

import numpy as np
import pandas as pd
import pandas as pd
import matplotlib
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn import metrics
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report,accuracy_score, precision_score, recall_score, confusion_matrix
from sklearn.linear_model import LinearRegression, LogisticRegression

"""
## Intro to NumPy Arrays
"""
single_array = np.array([7,8,9])
print (single_array)

multi_dim_array = np.array([(1,2,3),(7,8,9)])
print('Multi dimensional array: \n', multi_dim_array)
print(multi_dim_array.shape)


"""
# Real life ML example (Credit Card fraud detection)

  To get some input data use:
> wget https://www.dropbox.com/s/18vhxydhoe3g84n/creditcard%202.csv


## Import data from CSV
"""

data_df = pd.read_csv('/content/creditcard 2.csv')


"""## Overview of the data structure"""

data_df.head()


"""## Basic analysis"""

data_df.shape


"""### Statistics"""

data_df[['Amount', 'Time', 'Class']].describe()

data_df.columns

data_df.isna().any()

data_df['Class'].tail(10)


"""### Visualization

#### Global overview
"""

plt.title('Bar plot for Fraud vs Normal Transactions')
sns.barplot(x = 'Fraud', y = 'Ok Transaction', data = plot_data, palette='Blues', edgeColor='w')

"""#### Distribution Time vs Amount"""

x=data_df['Amount']
y=data_df['Time']
plt.plot(x,y)
plt.title('Time vs Amount')

plt.figure(figsize=(10,8),)
plt.title('Amount distribution')
sns.distplot(data_df['Amount'], color='red')

"""#### Scatterplot Amount vs Time
Visualization of the outliers. For example too big amount in an unusual time, or any difference from the average.
"""

fig, ax = plt.subplots(figsize=(16,8))
ax.scatter(data_df['Amount'], data_df['Time'])
ax.set_xlabel('Amount')
ax.set_ylabel('Time')
plt.show()

"""#### Correlation heatmap"""

correlation_metrics = data_df.corr()
fig = plt.figure(figsize=(14,9))
sns.heatmap(correlation_metrics, vmax=.9 , square=True)
plt.show()

"""## Classification"""

nfcount=0
notFroud=data_df['Class']
for i in range(len(notFroud)):
  if notFroud[i]==0:
    nfcount = nfcount +1

nfcount
per_nf = (nfcount/len(notFroud))*100
print (per_nf)

fcount = 0
Fraud = data_df['Class']
for i in range(len(Fraud)):
  if Fraud[i] == 1:
    fcount = fcount + 1

fcount
per_f = (fcount/len(Fraud))*100
per_f

plot_data = pd.DataFrame()
plot_data['Fraud'] = Fraud
plot_data['Ok Transaction'] = notFroud
plot_data

"""## Data cleaning
... and splitting the dataset to training and testing parts.
"""

x=data_df.drop(['Class'], axis =1 )
y=data_df['Class']
xtrain, xtest, ytrain, ytest = train_test_split(x,y, test_size=0.2, random_state = 42)

"""## Regression
Training and result accuracy...
"""

linearreg = LinearRegression()
linearreg.fit(xtrain, ytrain)

y_pred = linearreg.predict(xtest)

"""#### Linear regressiopn accuracy"""

accuracy = linearreg.score(xtrain, ytrain)
print('Accuracy score of LinReg: ', accuracy)

logreg = LogisticRegression()
logreg.fit(xtrain, ytrain)

"""#### Logaritmic regression accuracy
Better in this situation becausse the data is not continous.
"""

logaccuracy = logreg.score(xtrain, ytrain)
logaccuracy

"""## Confusion matrix (trained model fitting results)
_Wikipedia: In the field of machine learning and specifically the problem of statistical classification, a confusion matrix, also known as an **error matrix**,[8] is a specific table layout that allows visualization of the performance of an algorithm, typically a supervised learning one (in unsupervised learning it is usually called a matching matrix). Each row of the matrix represents the instances in a predicted class while each column represents the instances in an actual class (or vice versa).[9] The name stems from the fact that it makes it easy to see if the system is confusing two classes (i.e. commonly mislabeling one as another)._
"""

y_pred = logreg.predict(xtest)
cm = metrics.confusion_matrix(ytest, y_pred)
print('Shape of the dataframe: ', data_df.shape)
print ('Confusion Matrix: \n', cm)

